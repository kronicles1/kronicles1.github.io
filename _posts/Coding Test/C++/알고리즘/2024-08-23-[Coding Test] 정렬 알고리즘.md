---
layout: single
title: "[Coding Test] 알고리즘 - 정렬 알고리즘"
categories: [codingtest, c++]
sidebar:
    nav: "docs"
---

## Bubble Sort
> 버블 정렬 알고리즘은 인접한 두 개의 데이터 크기를 비교하며 정렬하는 알고리즘이다. <br/>
> O(n^2)의 시간 복잡도를 가진다. <br/>
> 간단하게 구현할 수 있지만 다른 정렬 알고리즘보다 속도가 느린 편이다. <br/>

## Bubble Sort 방법
> 비교 연산이 필요한 루프 범위를 설정한다. <br/>
> 인접한 데이터 값을 비교한다. <br/>
> swap 조건에 부합하면 swap 연산을 수행한다. <br/>
> 루프 범위가 끝날때까지 위의 과정을 수행한다. <br/>
> 정렬된 영역을 설정하고 다음 루프를 실행할때는 이 영역을 제외한다. <br/>
> 비교 대상이 없을때까지 위 과정을 반복한다. <br/>


## Selection Sort
> 선택 정렬 알고리즘은 대상 데이터에서 최대나 최소 데이터를 나열된 순으로 찾아가며 정렬하는 알고리즘이다. <br/>
> O(n^2)의 시간 복잡도를 가진다. <br/>
> 구현 방법이 복잡하고 다른 정렬 알고리즘보다 속도가 느려 코딩테스테에서 잘 선택하지 않는다. <br/>

## Bubble Sort 방법
> 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다. <br/>
> 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap한다. <br/>
> 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬의 범위를 축소한다. <br/>
> 전체 데이터 크기만큼 index가 커질때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다. <br/>


## Insertion Sort
> 삽입 정렬 알고리즘은 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입하여 정렬하는 알고리즘이다. <br/>
> O(n^2)의 시간 복잡도를 가진다. <br/>
> 구현하기가 쉬운 편이지만 다른 정렬 알고리즘보다 느린 편이다. <br/>
> 적절한 삽입 위치를 탐색하는 부분에서 이진탐색(Binary Search) 등과 같은 탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있다. <br/>

## Insertion Sort 방법
> 현재 index에 있는 데이터 값을 선택한다. <br/>
> 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색한다. <br/>
> 삽입 위치부터 index애 있는 위치까지 shift 연산을 수행한다. <br/>
> 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행한다. <br/>
> 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복한다. <br/>


## Quick Sort
> 퀵 정렬 알고리즘은 기준값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘이다. <br/>
> 기준값이 어떻게 선정되는지가 시간 복잡도에 많은 영향을 미친다. <br/>
> 평균 시간복잡도는 O(nlogn)이고 최악의 경우 O(n^2)의 시간 복잡도를 가진다. <br/>
> 시간복잡도가 준수해 코딩테스트에서 종종 응용되고 재귀함수의 형태로 직접 구현해보는 것이 바람직하다. <br/>

## Quick Sort 방법
> 데이터를 분할하는 pivot을 설정한다.
> pivot을 기준으로 다음 a~e 과정을 거쳐 데이터를 2개의 집합으로 분리한다.
    > a. start가 가리키는 데이터가 pivot 데이터보다 작으면 start를 오른쪽으로 1칸 이동한다.
    > b. end가 가리키는 데이터가 pivot 데이터보다 크면 end를 왼쪽으로 1칸 이동한다.
    > c. start가 가리키는 데이터가 pivot 데이터보다 크고, end가 가리키는 데이터가 pivot 데이터보다 작으면 star와 end가 가리키는 데이터를 swap하고 start는 오른쪽, end는 왼쪽으로 1칸씩 이동한다.
    > start와 end가 만날 때까지 a~c를 반복한다.
    >start와 end가 만나면 만난 지점에서 가리키는 데이터와 pivot 데이터를 비교하여 pivot 데이터가 크면 만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에 pivot이 가리키는 데이터를 삽입한다.
> 분리 집합에서 각각 다시 pivot을 선정한다.
> 분리 집합이 1개 이하가 될떄까지 과정 1~3을 반복한다.