---
layout: single
title: "[Coding Test] 자료구조 - 그래프"
categories: [codingtest, c++]
sidebar:
    nav: "docs"
---

## 그래프
> 그래프를 표현할 수 있는 방법은 3가지가 있다. <br/>
> 에지 리스트, 인접 행렬, 인접 리스트. <br/>

## 에지 리스트
> 에지 리스트는 에지를 중심으로 그래프를 표현한다. <br/>
> 배열에 출발 노드, 도착 노드, 가중치 등을 저장하여 에지를 표현한다. <br/>
> 가중치가 없는 그래프는 배열의 열을 2개로 두어서 출발과 도착 노드를 표시한다. <br/>
> 가중치가 있는 그래프는 배열의 열을 3개로 두어서 출발, 도착 노드와 함께 가중치를 표시한다. <br/>
> 에지 리스트는 노드 사이의 최단 거리를 구하는 벨만-포드나 최소 신장 트리를 찾는 크루스칼 알고리즘에 사용하며 노드 중심 알고리즘에는 잘 사용하지 않는다. <br/>

## 인접 행렬
> 인접 행렬은 2차원 자료구조로 이용하여 그래프를 표현한다. <br/>
> 에지 리스트와 다르게 노드 중심으로 그래프를 표현한다. <br/>
> 가중치가 없는 그래프의 경우 5X5 행렬 A에서 1->2로 가는 경우가 있으면 A[1][2]=1을 저장한다. (1인 이유는 가중치가 없기 때문) <br/>
> 가중치가 있는 그래프의 경우 5X5 행렬 A에서 1->2로 가는 경우가 있으면 A[1][2]=가중치를 저장한다.  <br/>
> 인접 행렬을 이용한 그래프 구현은 쉬우나 노드와 관련된 에지를 탐색하기 위해 N번 접근해야 하므로 시간 복잡도가 인접리스트에 비해 느리고 공간 효율성이 떨어진다. <br/>

## 인접 리스트
> C++의 인접 리스트는 이차원 벡터로 그래프를 표시한다.  <br/>
> 가중치가 없는 그래프의 경우 vector<*vector<*int*>*> A로 선언해 N 노드와 연결된 노드들을 A[N]에 push_back 해준다. <br/>
> 가중치가 있는 그래프의 경우 typedef pair<*int*, *int*> Node / vector<*vector<*Node*>*> A로 선언해 N 노드와 연결된 노드들을 A[N]에 push_back 해준다. (Node의 second에는 가중치가 들어간다) <br/>
> 이때 양방향의 경우 두 노드 모두에 대해 push_back을 진행해준다. <br/>
> 인접 리스트는 복잡하지만 탐색 시간이 매우 뛰어나고 공간 효율성이 좋아 메모리 초과 에러도 잘 발생하지 않는다. <br/>
> 실제로 코딩 테스트에서 인접 리스트를 통해 그래프 구현을 선호하고 DFS, BFS와 함께 많이 사용된다.  <br/>
